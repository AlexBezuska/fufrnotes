#!/usr/bin/env bash
set -euo pipefail

# Creates a new Servertron app folder with a Postgres container using the same pattern as Passhroom:
# - app root: <servertron-root>/<app>/
# - docker-compose.yml with:
#     <app>-db (postgres:16)
#     named volume for PGDATA (avoids host filesystem permission weirdness)
# - .env with <APP>_DB_PASSWORD
#
# Run from your local machine (requires ssh to servertron).

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR" && pwd)"

if [[ -f "$REPO_ROOT/.deploy.env" ]]; then
  set -a
  # shellcheck disable=SC1091
  . "$REPO_ROOT/.deploy.env"
  set +a
fi

DEPLOY_HOST="${DEPLOY_HOST:-}"
DEPLOY_USER="${DEPLOY_USER:-}"
DEPLOY_SSH_PORT="${DEPLOY_SSH_PORT:-22}"

SERVERTRON_ROOT="${SERVERTRON_ROOT:-}"
PG_VERSION="${PG_VERSION:-16}"

APP_SLUG=""
DB_NAME=""
DB_USER=""
DB_CONTAINER=""
REMOTE_DIR=""
PASSWORD_VAR=""
PRINT_ONLY="false"

usage() {
  cat <<EOF
Usage:
  scripts/servertron/scaffold-postgres-app.sh --app <slug>

Optional:
  --db-name <name>       Default: derived from --app (hyphens -> underscores)
  --db-user <user>       Default: derived from --app (hyphens -> underscores)
  --db-container <name>  Default: <app>-db
  --remote-dir <path>    Default: <servertron-root>/<app>
  --pg-version <major>   Default: $PG_VERSION
  --password-var <VAR>   Default: <APP>_DB_PASSWORD (uppercased)
  --print-only           Print what would be created; do not SSH

Env overrides (SSH):
  DEPLOY_HOST, DEPLOY_USER, DEPLOY_SSH_PORT

Example:
  scripts/servertron/scaffold-postgres-app.sh --app notes
  scripts/servertron/scaffold-postgres-app.sh --app my-app --db-name my_app --db-user my_app
EOF
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --app) APP_SLUG="$2"; shift 2 ;;
    --db-name) DB_NAME="$2"; shift 2 ;;
    --db-user) DB_USER="$2"; shift 2 ;;
    --db-container) DB_CONTAINER="$2"; shift 2 ;;
    --remote-dir) REMOTE_DIR="$2"; shift 2 ;;
    --pg-version) PG_VERSION="$2"; shift 2 ;;
    --password-var) PASSWORD_VAR="$2"; shift 2 ;;
    --print-only) PRINT_ONLY="true"; shift 1 ;;
    -h|--help) usage; exit 0 ;;
    *) echo "Unknown arg: $1" >&2; usage; exit 2 ;;
  esac
done

if [[ -z "$APP_SLUG" ]]; then
  echo "ERROR: --app is required" >&2
  usage
  exit 2
fi

if [[ "$PRINT_ONLY" != "true" ]]; then
  if [[ -z "$DEPLOY_HOST" || -z "$DEPLOY_USER" || -z "$SERVERTRON_ROOT" ]]; then
    echo "ERROR: Missing deploy configuration." >&2
    echo "Set DEPLOY_HOST, DEPLOY_USER, and SERVERTRON_ROOT" >&2
    echo "Tip: copy .deploy.env.example -> .deploy.env" >&2
    exit 2
  fi
fi

app_ident="${APP_SLUG//-/_}"
app_upper="$(printf '%s' "$app_ident" | tr '[:lower:]' '[:upper:]')"

DB_NAME="${DB_NAME:-$app_ident}"
DB_USER="${DB_USER:-$app_ident}"
DB_CONTAINER="${DB_CONTAINER:-$APP_SLUG-db}"
REMOTE_DIR="${REMOTE_DIR:-$SERVERTRON_ROOT/$APP_SLUG}"
PASSWORD_VAR="${PASSWORD_VAR:-${app_upper}_DB_PASSWORD}"

compose_file="docker-compose.yml"
volume_name="${app_ident}_db_data"
service_name="${APP_SLUG}-db"

compose_content=$(cat <<EOF
services:
  $service_name:
    image: postgres:$PG_VERSION
    container_name: $DB_CONTAINER
    environment:
      POSTGRES_DB: $DB_NAME
      POSTGRES_USER: $DB_USER
      POSTGRES_PASSWORD: \${$PASSWORD_VAR}
    volumes:
      - $volume_name:/var/lib/postgresql/data
    networks:
      - ${app_ident}_internal

volumes:
  $volume_name:

networks:
  ${app_ident}_internal:
    driver: bridge
EOF
)

env_example=$(cat <<EOF
# Generated by scaffold-postgres-app.sh
$PASSWORD_VAR=CHANGE_ME
EOF
)

if [[ "$PRINT_ONLY" == "true" ]]; then
  echo "REMOTE_DIR=$REMOTE_DIR"
  echo
  echo "--- $compose_file ---"
  printf '%s\n' "$compose_content"
  echo
  echo "--- .env.example ---"
  printf '%s\n' "$env_example"
  exit 0
fi

REMOTE="${DEPLOY_USER}@${DEPLOY_HOST}"
SSH_OPTS=(
  -p "$DEPLOY_SSH_PORT"
  -o BatchMode=yes
  -o ConnectTimeout=10
)

echo "Connecting to $REMOTE ..."
ssh "${SSH_OPTS[@]}" "$REMOTE" "mkdir -p '$REMOTE_DIR'"

echo "Writing $REMOTE_DIR/$compose_file ..."
printf '%s\n' "$compose_content" | ssh "${SSH_OPTS[@]}" "$REMOTE" "cat > '$REMOTE_DIR/$compose_file'"

echo "Writing $REMOTE_DIR/.env.example ..."
printf '%s\n' "$env_example" | ssh "${SSH_OPTS[@]}" "$REMOTE" "cat > '$REMOTE_DIR/.env.example'"

# Create .env if missing, with a generated password.
echo "Ensuring $REMOTE_DIR/.env exists (with a generated password) ..."
ssh "${SSH_OPTS[@]}" "$REMOTE" "
  set -euo pipefail
  cd '$REMOTE_DIR'
  if [[ -f .env ]]; then
    echo 'OK: .env already exists; leaving as-is.'
    exit 0
  fi
  if command -v openssl >/dev/null 2>&1; then
    pw=\"\$(openssl rand -hex 24)\"
  else
    # Fallback: best-effort (less ideal, but avoids extra deps)
    pw=\"\$(date +%s)-\$(id -u)-\$(uname -n)\"
  fi
  printf '%s=%s\n' '$PASSWORD_VAR' \"\$pw\" > .env
  chmod 600 .env
  echo 'Created .env'
"

echo "Starting Postgres container ..."
ssh "${SSH_OPTS[@]}" "$REMOTE" "set -euo pipefail; cd '$REMOTE_DIR' && docker compose --env-file .env -f '$compose_file' up -d"

echo "Smoke test (SELECT 1) ..."
ssh "${SSH_OPTS[@]}" "$REMOTE" "set -euo pipefail; docker exec -i '$DB_CONTAINER' psql -U '$DB_USER' -d '$DB_NAME' -c 'select 1;' >/dev/null"

cat <<EOF

OK: Postgres created for app '$APP_SLUG'.

Server files:
  - $REMOTE_DIR/$compose_file
  - $REMOTE_DIR/.env (chmod 600)

Connection string (from another container in the same compose):
  postgres://$DB_USER:<$PASSWORD_VAR>@$service_name:5432/$DB_NAME

Backup example (from local, using this repo scripts):
  SERVER=$REMOTE REMOTE_DIR=$REMOTE_DIR DB_CONTAINER=$DB_CONTAINER DB_USER=$DB_USER DB_NAME=$DB_NAME npm run db:backup

Restore example:
  SERVER=$REMOTE REMOTE_DIR=$REMOTE_DIR DB_CONTAINER=$DB_CONTAINER DB_USER=$DB_USER DB_NAME=$DB_NAME STOP_SERVICE= BACKUP_FILE=backups/<file>.dump npm run db:restore
EOF
